<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures and Algorithms Course</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
        code {
            font-family: "Courier New", monospace;
            background: #eef;
            padding: 2px 4px;
            border-radius: 4px;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <h1>Introduction to the Course</h1>
    <p>This course provides an in-depth exploration of data structures and algorithms, focusing on their theoretical foundations and practical applications. Through structured learning, students are equipped with the skills to solve computational problems efficiently by understanding the principles behind different data storage, retrieval, and processing techniques.</p>

    <h2>Data Structures and Algorithms</h2>
    <h3>Fundamental and Advanced Data Structures:</h3>
    <ul>
        <li>Arrays</li>
        <li>Linked lists</li>
        <li>Stacks</li>
        <li>Queues</li>
        <li>Trees: AVL, BST, Red-Black trees, 2-3 trees</li>
        <li>Heaps</li>
        <li>Tries</li>
        <li>Graphs</li>
    </ul>

    <h3>Key Algorithmic Techniques:</h3>
    <ul>
        <li>Recursion and Iteration</li>
        <li>Backtracking</li>
        <li>Sorting: Merge sort, Quick sort, Heap sort</li>
        <li>Searching: Binary search</li>
        <li>Graph algorithms: DFS, BFS, Dijkstra's, Prim's, Kruskal's</li>
    </ul>

    <h2>Connecting the Course with Real-Time Applications</h2>
    <p>The knowledge from this course directly connects to real-world applications such as optimizing routes in map services, managing hierarchical data in databases, and developing efficient search algorithms for web engines. Understanding time and space complexity ensures scalable solutions for applications like e-commerce, healthcare systems, and financial modeling.</p>

    <h2>1. Problems in Nature</h2>

    <h3>Iteration:</h3>
    <pre><code>int findMax(int arr[], int size) {
    if (size <= 0) {
        throw invalid_argument("Array size must be greater than zero.");
    }

    int max_value = arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > max_value) {
            max_value = arr[i];
        }
    }
    return max_value;
}</code></pre>

    <h3>Recursion:</h3>
    <pre><code>int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>

    <h3>Backtracking:</h3>
    <p>Solving the N-Queens problem:</p>
    <pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;

bool isSafe(int board[][10], int row, int col, int N) {
    for (int i = 0; i < row; i++) {
        if (board[i][col] == 1 || 
            (col - (row - i) >= 0 && board[i][col - (row - i)] == 1) || 
            (col + (row - i) < N && board[i][col + (row - i)] == 1)) {
            return false;
        }
    }
    return true;
}

bool solveNQueens(int board[][10], int row, int N) {
    if (row == N) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                cout << (board[i][j] ? "Q " : ". ");
            }
            cout << endl;
        }
        cout << endl;
        return true;
    }

    bool res = false;
    for (int col = 0; col < N; col++) {
        if (isSafe(board, row, col, N)) {
            board[row][col] = 1;
            res = solveNQueens(board, row + 1, N) || res;
            board[row][col] = 0;
        }
    }
    return res;
}

void solveNQueens(int N) {
    int board[10][10] = {0};
    if (!solveNQueens(board, 0, N)) {
        cout << "Solution does not exist!" << endl;
    }
}

int main() {
    int N;
    cout << "Enter the value of N: ";
    cin >> N;
    solveNQueens(N);
    return 0;
}</code></pre>

    <h2>2. Space and Time Efficiency</h2>
    <h3>Importance of Analyzing Algorithmic Complexity:</h3>
    <p>Analyzing algorithm complexity ensures scalability and efficient handling of larger data.</p>

    <h3>Orders of Growth:</h3>
    <ul>
        <li><code>O(1)</code>: Constant time</li>
        <li><code>O(log n)</code>: Logarithmic time</li>
        <li><code>O(n)</code>: Linear time</li>
        <li><code>O(n&sup2;)</code>: Quadratic time</li>
    </ul>

    <h2>...</h2>
    <p>Continue with remaining sections as structured above...</p>
</body>
</html>



            <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflection - Design and Analysis of Algorithms</title>
    <style>
        body {
            background-color: lavender;
            color: black;
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
        }
        h1, h2 {
            color: black;
        }
        h1 {
            text-align: center;
        }
        ul {
            margin-left: 20px;
        }
        b {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>COURSE REFLECTION</h1>
    <h2>Design and Analysis of Algorithms</h2>

    <h3><b>INTRODUCTION TO DESIGN AND ANALYSIS OF ALGORITHMS</b></h3>
    <p>
        The course on Design and Analysis of Algorithms introduces the principles of algorithmic problem-solving. It focuses on understanding how algorithms work, measuring their efficiency, and designing effective solutions to computational problems.
    </p>

    <h3><b>CONCEPTS COVERED IN THIS COURSE:</b></h3>
    <ul>
        <li><b>Linear and Non-linear Data Structures:</b>
            <ul>
                <li>Arrays</li>
                <li>Linked List</li>
                <li>Stacks and Queues</li>
                <li>Trees:
                    <ul>
                        <li>Binary Trees</li>
                        <li>2-3 Trees</li>
                        <li>Lookup Table</li>
                        <li>Tries</li>
                        <li>AVL Trees</li>
                        <li>Red-Black Trees</li>
                        <li>Skip Lists</li>
                        <li>Segment Trees</li>
                    </ul>
                </li>
                <li>Graphs (Weighted/Unweighted, Directed/Undirected)</li>
                <li>Heaps</li>
                <li>HashMaps</li>
                <li>Union-Find (Disjoint Set Union)</li>
            </ul>
        </li>
        <li><b>Algorithms:</b>
            <ul>
                <li><b>Sorting Algorithms:</b>
                    <ul>
                        <li>Bubble Sort</li>
                        <li>Insertion Sort</li>
                        <li>Selection Sort</li>
                        <li>Merge Sort</li>
                        <li>Quick Sort</li>
                        <li>Heap Sort</li>
                    </ul>
                </li>
                <li><b>String Matching Algorithms:</b>
                    <ul>
                        <li>Brute Force</li>
                        <li>Boyer-Moore</li>
                        <li>KMP</li>
                        <li>Rabin-Karp</li>
                    </ul>
                </li>
                <li><b>Graph Algorithms:</b>
                    <ul>
                        <li>Breadth-First Search (BFS)</li>
                        <li>Depth-First Search (DFS)</li>
                        <li>Kruskal’s Algorithm</li>
                        <li>Dijkstra’s Algorithm</li>
                        <li>Bellman-Ford Algorithm</li>
                        <li>Floyd-Warshall Algorithm</li>
                    </ul>
                </li>
                <li><b>Backtracking Algorithms:</b>
                    <ul>
                        <li>N-Queen Problem</li>
                        <li>Subset Generation</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ul>

    <h3><b>What are the challenges in learning/understanding the above concepts?</b></h3>
    <p>
        Learning data structures and algorithms can feel overwhelming at first because many concepts are abstract and require a blend of logic, math, and coding skills. Understanding how different data structures like trees, graphs, or heaps work, and when to use them, is a crucial step. Algorithms, such as sorting or searching, challenge you to think critically about efficiency and optimization. Debugging recursive calls or grasping complex techniques like dynamic programming can be tricky but rewarding with practice. The key is patience—breaking down problems, using visuals to understand processes, and practicing consistently will build confidence and make these concepts manageable.
    </p>

    <h3><b>What are the challenges in correlating the real-world application?</b></h3>
    <p>
        It can be hard to see how data structures and algorithms apply to real life because they often seem abstract. Real-world problems are also more complex than textbook examples.
    </p>

    <h3><b>How do you determine the most efficient approach/design techniques when solving a complex problem?</b></h3>
    <p>
        To determine the most efficient approach for solving a complex problem, I start by breaking the problem into smaller parts and understanding the requirements. Then analyse the time and space complexity of each approach to see which one is faster and uses less memory. Then choose the method that balances efficiency and simplicity and test it with different examples to ensure it works well in all scenarios.
    </p>
</body>
</html>
